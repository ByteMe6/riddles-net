import { useState, useEffect, useContext } from 'react';
import { auth, db } from './firebaseConfig';
import { ref, set, get } from 'firebase/database';
import './RiddleChat.scss';
import "/public/gemini-logo.png";
import { LangContext } from './App';

const API_KEY = import.meta.env.VITE_API_KEY;
const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${API_KEY}`;

const translations = {
  eng: {
    title: 'Riddles from AI',
    description: 'Here will be some riddles generated by AI (Gemini).',
    getRiddle: 'Get a riddle',
    generating: 'Generating...',
    check: 'Check',
    correct: 'Correct! 🎉. You can click "get a riddle" and get another one',
    incorrect: 'Incorrect. Try another one (click get a riddle)!',
    answer: 'Answer:',
    riddle: 'Riddle:',
    yourAnswer: 'Your answer...'
  },
  ru: {
    title: 'Загадки от ИИ',
    description: 'Здесь будут загадки, сгенерированные ИИ (Gemini).',
    getRiddle: 'Получить загадку',
    generating: 'Генерируется...',
    check: 'Проверить',
    correct: 'Верно! 🎉. Можете нажать "получить загадку" и получить новую',
    incorrect: 'Неверно. Попробуйте другую (нажмите получить загадку)!',
    answer: 'Ответ:',
    riddle: 'Загадка:',
    yourAnswer: 'Ваш ответ...'
  },
  ua: {
    title: 'Загадки від ШІ',
    description: 'Тут будуть загадки, згенеровані ШІ (Gemini).',
    getRiddle: 'Отримати загадку',
    generating: 'Генерується...',
    check: 'Перевірити',
    correct: 'Вірно! 🎉. Можна натиснути "отримати загадку" і отримати нову',
    incorrect: 'Невірно. Спробуйте іншу (натисніть отримати загадку)!',
    answer: 'Відповідь:',
    riddle: 'Загадка:',
    yourAnswer: 'Ваша відповідь...'
  }
};

function RiddleChat() {
  const [riddle, setRiddle] = useState('');
  const [answer, setAnswer] = useState('');
  const [userAnswer, setUserAnswer] = useState('');
  const [result, setResult] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const { lang: contextLang } = useContext(LangContext);
  const [lang, setLang] = useState(contextLang || 'eng');

  useEffect(() => {
    const user = auth.currentUser;
    if (user) {
      const userRef = ref(db, `users/${user.uid}`);
      get(userRef).then((snapshot) => {
        const data = snapshot.val();
        if (data && data.lang) {
          setLang(data.lang);
        }
        if (!data) {
          set(userRef, {
            username: user.displayName || user.email,
            score: 0,
            lang: 'eng',
          });
          set(ref(db, `leaderboard/${user.uid}`), {
            username: user.displayName || user.email,
            score: 0,
          });
        }
      });
    }
  }, []);

  useEffect(() => { setLang(contextLang); }, [contextLang]);

  async function getRiddle() {
    setLoading(true);
    setError('');
    setResult('');
    setRiddle('');
    setAnswer('');
    setUserAnswer('');
    try {
      let prompt = '';
      if (lang === 'eng') {
        prompt = 'Come up with an interesting riddle in English and give only the riddle, and write the answer separately. RIDDLE MUST BE IN ENGLISH. Format: Riddle: ... Answer: ...';
      } else if (lang === 'ru') {
        prompt = 'Придумай интересную загадку на русском языке и дай только загадку, а ответ напиши отдельно. ЗАГАДКА ДОЛЖНА БЫТЬ НА РУССКОМ. Формат: Загадка: ... Ответ: ...';
      } else if (lang === 'ua') {
        prompt = 'Придумай цікаву загадку українською мовою і дай тільки загадку, а відповідь напиши окремо. ЗАГАДКА МАЄ БУТИ УКРАЇНСЬКОЮ. Формат: Загадка: ... Відповідь: ...';
      }
      const res = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: prompt }] }],
        }),
      });
      const data = await res.json();
      let match;
      if (lang === 'eng') {
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
          const text = data.candidates[0].content.parts.map((p) => p.text).join(' ');
          match = text.match(/Riddle:(.*)Answer:(.*)/is);
        }
      } else if (lang === 'ru') {
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
          const text = data.candidates[0].content.parts.map((p) => p.text).join(' ');
          match = text.match(/Загадка:(.*)Ответ:(.*)/is);
        }
      } else if (lang === 'ua') {
        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
          const text = data.candidates[0].content.parts.map((p) => p.text).join(' ');
          match = text.match(/Загадка:(.*)Відповідь:(.*)/is);
        }
      }
      if (match) {
        setRiddle(match[1].trim());
        setAnswer(match[2].trim());
      } else if (data.error) {
        setError(`Gemini API error: ${data.error.message || 'Unknown error'} (code: ${data.error.code || 'no code'})`);
      } else {
        setError('Ошибка: не удалось получить загадку. Попробуйте ещё раз.');
      }
    } catch (e) {
      setError('API connection error: ' + e.message);
    } finally {
      setLoading(false);
    }
  }

  function normalizeAnswer(ans) {
    return ans
      .toLowerCase()
      .replace(/^(a|an)\s+/g, '')
      .trim();
  }

  function checkAnswer() {
    if (normalizeAnswer(userAnswer) === normalizeAnswer(answer)) {
      setResult(translations[lang].correct);
      const user = auth.currentUser;
      if (user) {
        const userRef = ref(db, `users/${user.uid}`);
        get(userRef).then((snapshot) => {
          const data = snapshot.val() || { score: 0, username: user.displayName || user.email };
          const newScore = (data.score || 0) + 1;
          set(userRef, {
            ...data,
            score: newScore,
          });
          set(ref(db, `leaderboard/${user.uid}`), {
            username: data.username,
            score: newScore,
          });
        });
      }
    } else {
      setResult(translations[lang].incorrect);
    }
  }

  return (
    <div className="riddle-chat-container">
      <h2 className="riddle-chat-title">
        {translations[lang].title}
        <img src="/gemini-logo.png" alt="Gemini logo" style={{ height: '1.2em', verticalAlign: 'middle' }} />
      </h2>
      <p className="riddle-text">
        {translations[lang].description}
      </p>
      <button
        onClick={getRiddle}
        disabled={loading}
        className={`riddle-chat-button ${loading ? 'riddle-chat-button-disabled' : ''}`}
      >
        {loading ? translations[lang].generating : translations[lang].getRiddle}
      </button>
      {error && <div className="riddle-chat-error">{error}</div>}
      {riddle && (
        <div className="riddle-chat-content">
          <div className="riddle-chat-label">{translations[lang].riddle}</div>
          <div className="riddle-chat-riddle">{riddle}</div>
          <div className="riddle-chat-input-row">
            <input
              type="text"
              placeholder={translations[lang].yourAnswer}
              value={userAnswer}
              onChange={(e) => setUserAnswer(e.target.value)}
              className="riddle-chat-input"
              disabled={!!result}
            />
            <button
              onClick={checkAnswer}
              className="riddle-chat-check-button"
              disabled={!!result}
            >
              {translations[lang].check}
            </button>
          </div>
          {result && <div className="riddle-chat-result">{result}</div>}
          {answer && result && <div className="riddle-chat-answer">{translations[lang].answer} {answer}</div>}
        </div>
      )}
    </div>
  );
}

export default RiddleChat;